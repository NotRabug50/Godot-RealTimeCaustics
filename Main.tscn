[gd_scene load_steps=15 format=2]

[ext_resource path="res://Assets/Materials/DarkTestMaterial.tres" type="Material" id=1]
[ext_resource path="res://Assets/Materials/RedTestMaterial.tres" type="Material" id=2]
[ext_resource path="res://Assets/Materials/CausticMaterial.tres" type="Material" id=3]
[ext_resource path="res://Assets/Scripts/Main.gd" type="Script" id=4]
[ext_resource path="res://Assets/Caustics/caustics-generator2.png" type="Texture" id=5]

[sub_resource type="SphereMesh" id=1]

[sub_resource type="CubeMesh" id=2]
size = Vector3( 4, 2, 4 )

[sub_resource type="CubeMesh" id=5]
size = Vector3( 4, 4, 4 )

[sub_resource type="Shader" id=6]
code = "shader_type spatial;
render_mode blend_add, cull_front, depth_test_disable;

uniform sampler2D caustics_noise;

uniform vec3 box_size = vec3(1.0);

// Caustics Parameters
uniform float caustics_scale = 1.0;
uniform float caustics_speed = 0.1;
uniform float caustics_strength = 0.5;
uniform float caustics_power = 1.0;
uniform float caustics_fade_radius = 0.8;
uniform float caustics_fade_strength = 0.5;
uniform float caustics_luminance_mask_strength = 1.2;
uniform float chroma_split = 0.1;
uniform sampler2D luma_gradient : hint_white;

varying mat4 vertex_camera;
varying mat4 vertex_world;
varying mat4 vertex_projection;
varying mat4 vertex_modelview;
void vertex(){
	vertex_camera = CAMERA_MATRIX;
	vertex_world = WORLD_MATRIX;
	vertex_projection = PROJECTION_MATRIX;
	vertex_modelview = MODELVIEW_MATRIX;
}

float insideBox3D(vec3 v, vec3 bottomLeft, vec3 topRight) {
	vec3 s = step(bottomLeft, v) - step(topRight, v);
	return s.x * s.y * s.z; 
}

float check_encompass_point(vec3 p){
	// p should be in world space
	vec3 hs = box_size / 2.0;
	
	vec3 bl = -hs + vertex_world[3].xyz;
	vec3 tr = hs + vertex_world[3].xyz;
	
	return insideBox3D(p, bl, tr);
}

mediump vec2 panner(mediump vec2 uv, mediump float speed, mediump float tiling){
	return (vec2(1, 0) * TIME * speed) + (uv * tiling);
}

mediump vec3 aberration_sample(sampler2D _CausticsTexture, mediump vec2 uv, mediump float split){
	mediump vec2 uv1 = uv + vec2(split, split);
	mediump vec2 uv2 = uv + vec2(split, -split);
	mediump vec2 uv3 = uv + vec2(-split, -split);
	
	mediump float r = texture(_CausticsTexture, uv1).r;
	mediump float g = texture(_CausticsTexture, uv2).r;
	mediump float b = texture(_CausticsTexture, uv3).r;
	
	return vec3(r, g, b);
}

float luminance(vec3 color){
	return (0.299*color.r + 0.587*color.g + 0.114*color.b);
}

varying vec3 positionWS;
varying vec3 positionOS;
varying vec3 screen_color;
varying float bbox_mask;
void fragment(){
	float depth = texture(DEPTH_TEXTURE, SCREEN_UV).x;
	vec3 ndc = vec3(SCREEN_UV, depth) * 2.0 - 1.0;
	vec4 view = INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
	view.xyz /= view.w;
	float linear_depth = -view.z;
	vec4 world = vertex_camera * INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
	
	positionWS = world.xyz / world.w;
	positionOS = positionWS - WORLD_MATRIX[3].xyz;
	bbox_mask = check_encompass_point(positionWS);
	
	screen_color = texture(SCREEN_TEXTURE, SCREEN_UV).rgb;
	
	// Want to do all the work in the light function
	// So we use additive blending and set albedo to zero
	ALBEDO = vec3(0.0);
}

// Stolen function from StackOverflow ;)
mat3 makeRotationDir(vec3 direction, vec3 up){
	mat3 rm;
	
	vec3 xaxis = cross(up, direction);
	xaxis = normalize(xaxis);
	
	vec3 yaxis = cross(direction, xaxis);
	yaxis = normalize(yaxis);
	
	rm[0].x = xaxis.x;
	rm[0].y = yaxis.x;
	rm[0].z = direction.x;
	
	rm[1].x = xaxis.y;
	rm[1].y = yaxis.y;
	rm[1].z = direction.y;
	
	rm[2].x = xaxis.z;
	rm[2].y = yaxis.z;
	rm[2].z = direction.z;
	
	return rm;
}

void light(){
	// Mapping texture
	vec3 world_light = (vec4(LIGHT, 1.0) * INV_CAMERA_MATRIX).xyz;
	mat3 lrm = makeRotationDir(world_light, vec3(0.0, 1.0, 0.0));
	mat4 t = mat4(lrm);
	t[3].xyz = positionWS;
	mediump vec2 uv = (t * vec4(positionWS, 1.0)).xy;
	mediump vec2 uv1 = panner(uv, 0.75 * caustics_speed, 1.0 / caustics_scale);
	mediump vec2 uv2 = panner(uv, caustics_speed, -1.0 / caustics_scale);
	
	mediump vec3 caus1 = aberration_sample(caustics_noise, uv1, chroma_split);
	mediump vec3 caus2 = aberration_sample(caustics_noise, uv2, chroma_split);
	caus1.rgb = pow(caus1.rgb, vec3(caustics_power));
	caus2.rgb = pow(caus2.rgb, vec3(caustics_power));
	
	mediump vec3 c = min(caus1.rgb, caus2.rgb) * caustics_strength;
	
	// Luminance Fade
	mediump float scene_luma = luminance(screen_color);
	scene_luma = texture(luma_gradient, vec2(scene_luma)).r;
	mediump float luminanceMask = mix(1.0, scene_luma, caustics_luminance_mask_strength);
	
	// Edge Fade
	mediump float edgeFadeMask = 1.0 - clamp((distance(positionOS, vec3(0.0)) - caustics_fade_radius) / (1.0 - caustics_fade_strength), 0.0, 1.0);
	
	DIFFUSE_LIGHT += c * bbox_mask * luminanceMask * edgeFadeMask;
}"

[sub_resource type="Gradient" id=7]
offsets = PoolRealArray( 0, 0.10559 )

[sub_resource type="GradientTexture" id=8]
gradient = SubResource( 7 )
width = 512

[sub_resource type="ShaderMaterial" id=9]
shader = SubResource( 6 )
shader_param/box_size = Vector3( 4, 4, 4 )
shader_param/caustics_scale = 6.234
shader_param/caustics_speed = 0.1
shader_param/caustics_strength = 0.626
shader_param/caustics_power = 2.105
shader_param/caustics_fade_radius = 2.228
shader_param/caustics_fade_strength = 0.5
shader_param/caustics_luminance_mask_strength = 1.2
shader_param/chroma_split = 0.002
shader_param/caustics_noise = ExtResource( 5 )
shader_param/luma_gradient = SubResource( 8 )

[sub_resource type="ProceduralSky" id=3]
sky_top_color = Color( 0.756863, 0.972549, 1, 1 )
sky_horizon_color = Color( 0.333333, 0.701961, 1, 1 )
sky_curve = 0.509117
ground_bottom_color = Color( 0.188235, 0.188235, 0.188235, 1 )
sun_latitude = 84.24

[sub_resource type="Environment" id=4]
background_mode = 2
background_sky = SubResource( 3 )

[node name="Main" type="Spatial"]
script = ExtResource( 4 )

[node name="TestScene" type="CSGCombiner" parent="."]

[node name="CSGBox" type="CSGBox" parent="TestScene"]
width = 8.0
height = 1.0
depth = 8.0
material = ExtResource( 1 )

[node name="CSGBox2" type="CSGBox" parent="TestScene"]
transform = Transform( 1, 0, 0, 0, -4.37114e-08, 1, 0, -1, -4.37114e-08, 0, 4, -4 )
width = 8.0
height = 1.0
depth = 8.0
material = ExtResource( 1 )

[node name="CSGBox3" type="CSGBox" parent="TestScene"]
transform = Transform( -4.37114e-08, -1, -4.37114e-08, 0, -4.37114e-08, 1, -1, 4.37114e-08, 1.91069e-15, -4, 4, 2.38419e-07 )
width = 8.0
height = 1.0
depth = 8.0
material = ExtResource( 1 )

[node name="CSGBox" type="CSGBox" parent="TestScene/CSGBox3"]
operation = 2
width = 6.0
material = ExtResource( 1 )

[node name="Sphere" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0.049006, 1.61372, 0.0612626 )
mesh = SubResource( 1 )
material/0 = ExtResource( 2 )

[node name="DirectionalLight" type="DirectionalLight" parent="."]
transform = Transform( 0.890554, -0.327443, 0.315744, -0.14325, 0.456928, 0.877893, -0.431732, -0.827042, 0.360013, 0, 7.85742, 0 )
shadow_enabled = true

[node name="Camera" type="Camera" parent="."]
transform = Transform( 1, 0, 0, 0, 0.949683, 0.313214, 0, -0.313214, 0.949683, 0, 3.05225, 3.76693 )

[node name="CausticVolume" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -0.0453606, 1.71073, -0.0858744 )
visible = false
mesh = SubResource( 2 )
material/0 = ExtResource( 3 )

[node name="CausticVolume_Alt" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -0.0453606, 2.01395, -0.0858744 )
mesh = SubResource( 5 )
material/0 = SubResource( 9 )

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource( 4 )
